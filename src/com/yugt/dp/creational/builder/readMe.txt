*定义:
将一个“复杂”对象的构建与它的表示分离,使得同样的构建过程可以“创建不同的表示”.


*角色：
Builder：抽象生成器角色，这是一个抽象接口，定义了创建负责对象的各个组成部分的公共接口。这个接口应该足够普遍，以便具体的生成器能够通过实现这个抽象接口的不同方式和不同部分生成不同的产品。
ConcreateBuilderA：具体生成器角色，继承并实现抽象生成器的接口，完成具体产品部件的建造。除此以外，具体生成器还需要额外提供一个检索产品的方法，以便指导者能在产品生成后获得它。这个方法通常包含的是复杂产品的装配逻辑。
Director：指导者角色，指导具体生成器来一步一步完成产品的创建。需要特别指出的是，指导者并不需要指导具体生成器生成的产品，它只需要了解如何使用生成器制造产品，制造出的产品的细节，只有具体生成器才知道。
Product：产品，被创建出来的复杂的产品。由ConcreteBuilder创建这个复杂产品的内部表示并定义它的装配过程。通常，Product定义了它的组成部件的类，以及将这些部件装配成最终产品的接口。一个系统中可能还有多个Product类，而且这些类之间不一定会有共同的接口，可以是完全互不相关的。


*
生成器模式的关键在于：将部件和组装过程分开


*
1.如何划分步骤是一个稳定的算法，而复杂对象的各个部分的创建过程则经常变化
2.通过把各部件的创建过程封装到生成器中，使得复杂对象的创建过程和最终表象实现分分离
3.使用生成器模式，隐藏了具体产品的表示方法、内部结构和装配过程。
4.通过定义一个新的生成器，就可以改变产品的内部表示。
5.生成器模式中的指导者角色控制着生成器生成部件的过程


*
应用场合：
1.池
在Java实际使用中,我们经常用到"池"(Pool)的概念,当资源提供者无法提供足够的资源,并且这些资源需要被很多用户反复共享时,就需要使用池.
"池"实际是一段内存,当池中有一些复杂的资源的"断肢"(比如数据库的连接池,也许有时一个连接会中断),如果循环再利用这些"断肢",将提高内存使用效率,提高池的性能.修改Builder模式中Director类使之能诊断"断肢"断在哪个部件上,再修复这个部件.


*
与抽象工厂模式的比较
生成器模式关注于将构造对象的过程和构造的各个部分分开，而抽象工厂关注于构建一个产品系列。实际上，最大的区别是生成器模式创建的产品不一定有共同的父类，只要有类似的构造过程即可。实际上我们常见到的文件资源管理器的实现完全可以使用生成器模式。
生成器模式和工厂模式很相象，但是它们有很明显的区别。那就是工厂模式只是根据给的参数不同，工厂"生产"并返回不同的对象。生成器模式除了根据不同参数"生产"不同对象外，这些不同的对象还包含着不同的数据。生成器模式比工厂模式复杂就复杂在多"数据"这一部分。

